{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/Material-T/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/Material-T/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/Material-T/source/css/post.styl","path":"css/post.styl","modified":0,"renderable":1},{"_id":"themes/Material-T/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/Material-T/source/css/Material_Icons.styl","path":"css/Material_Icons.styl","modified":0,"renderable":1},{"_id":"themes/Material-T/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/Material-T/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/Material-T/source/js/material-kit.min.js","path":"js/material-kit.min.js","modified":0,"renderable":1},{"_id":"themes/Material-T/source/js/post.js","path":"js/post.js","modified":0,"renderable":1},{"_id":"themes/Material-T/source/img/about-banner.jpg","path":"img/about-banner.jpg","modified":0,"renderable":1},{"_id":"themes/Material-T/source/css/Prettify/tomorrow-night-eighties.min.css","path":"css/Prettify/tomorrow-night-eighties.min.css","modified":0,"renderable":1},{"_id":"themes/Material-T/source/css/Prettify/github.min.css","path":"css/Prettify/github.min.css","modified":0,"renderable":1},{"_id":"themes/Material-T/source/css/Prettify/tomorrow.min.css","path":"css/Prettify/tomorrow.min.css","modified":0,"renderable":1},{"_id":"themes/Material-T/source/css/Prettify/tomorrow-night.min.css","path":"css/Prettify/tomorrow-night.min.css","modified":0,"renderable":1},{"_id":"themes/Material-T/source/img/archive-banner.jpg","path":"img/archive-banner.jpg","modified":0,"renderable":1},{"_id":"themes/Material-T/source/img/index-banner.jpg","path":"img/index-banner.jpg","modified":0,"renderable":1},{"_id":"themes/Material-T/source/js/core/popper.min.js","path":"js/core/popper.min.js","modified":0,"renderable":1},{"_id":"themes/Material-T/source/js/plugins/prettify.js","path":"js/plugins/prettify.js","modified":0,"renderable":1},{"_id":"themes/Material-T/source/js/core/bootstrap-material-design.min.js","path":"js/core/bootstrap-material-design.min.js","modified":0,"renderable":1},{"_id":"themes/Material-T/source/js/plugins/moment.min.js","path":"js/plugins/moment.min.js","modified":0,"renderable":1},{"_id":"themes/Material-T/source/js/core/jquery.min.js","path":"js/core/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/Material-T/source/img/post-banner.jpg","path":"img/post-banner.jpg","modified":0,"renderable":1},{"_id":"themes/Material-T/source/css/Material-Kit.styl","path":"css/Material-Kit.styl","modified":0,"renderable":1}],"Cache":[{"_id":"themes/Material-T/.gitignore","hash":"bce1a0b5bd710dde3fd6d66792f7c92284edacbf","modified":1552118139290},{"_id":"themes/Material-T/_config.yml","hash":"5c5c157405f1ae216ebdc306f196f2ed4d737618","modified":1552120872655},{"_id":"themes/Material-T/LICENSE","hash":"ef7d4d41772a6ee62ee25ae6cb9e8afefcb70bee","modified":1552118139291},{"_id":"themes/Material-T/Changelog.md","hash":"f1c7d14dbe8adfb143fe030cc1962848501c83ba","modified":1552118139290},{"_id":"themes/Material-T/README.md","hash":"7b1efc662f4b45b1e7cfc10bbf7b2a96b6337210","modified":1552118139291},{"_id":"themes/Material-T/lanaguages/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552118139292},{"_id":"themes/Material-T/script/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1552118139300},{"_id":"source/about/index.md","hash":"ff7d16f0729e642969dc711b0afa3358b6fbb617","modified":1552119075496},{"_id":"themes/Material-T/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1552118139277},{"_id":"source/_posts/hello-world.md","hash":"acb473d21d33f0b923bfc2309cbecf7d2452ea99","modified":1552117339597},{"_id":"themes/Material-T/.git/config","hash":"2a93a8d93dc01e3464c31fd4aaa40f7fb6cc34e2","modified":1552118139282},{"_id":"themes/Material-T/.git/index","hash":"a07aec4570c02dd83e52a3b66b34cabf7dd9bea5","modified":1552118139324},{"_id":"themes/Material-T/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1552117950466},{"_id":"themes/Material-T/.git/packed-refs","hash":"6f847a8fd5fcb40f4d05318032106bb2dd42065d","modified":1552118139270},{"_id":"themes/Material-T/layout/archive.ejs","hash":"cbe7faee71f67a3a19f5ca1d98d8b3e437f3a7ef","modified":1552118139296},{"_id":"themes/Material-T/layout/layout.ejs","hash":"776c9334e0690a446e8e69ddc91bc7f98d5a3ea9","modified":1552118139296},{"_id":"themes/Material-T/layout/index.ejs","hash":"1ccc131618e71098da733504589ab681ca8e0c25","modified":1552118139296},{"_id":"themes/Material-T/layout/post.ejs","hash":"97a698be770ed1ef45245fad255ec6824be584b8","modified":1552118139297},{"_id":"themes/Material-T/layout/page.ejs","hash":"669592b432ab1044e3ac06404caaaf6a948e1152","modified":1552118139297},{"_id":"themes/Material-T/source/favicon.png","hash":"7e79eceaaab4def3d4b905d1c69dc04d52f18f06","modified":1552118139308},{"_id":"themes/Material-T/source/apple-touch-icon.png","hash":"7e79eceaaab4def3d4b905d1c69dc04d52f18f06","modified":1552118139300},{"_id":"themes/Material-T/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1552117950468},{"_id":"themes/Material-T/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1552117950469},{"_id":"themes/Material-T/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1552117950470},{"_id":"themes/Material-T/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1552117950467},{"_id":"themes/Material-T/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1552117950468},{"_id":"themes/Material-T/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1552117950468},{"_id":"themes/Material-T/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1552117950467},{"_id":"themes/Material-T/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1552117950470},{"_id":"themes/Material-T/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1552117950471},{"_id":"themes/Material-T/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1552117950465},{"_id":"themes/Material-T/.git/logs/HEAD","hash":"9ecfaf3208bfde7506fb8354dc214da6da682311","modified":1552118139280},{"_id":"themes/Material-T/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1552117950469},{"_id":"themes/Material-T/layout/_partial/footer.ejs","hash":"8cda201dc8f1f2801fb4980419e82bd7ea964950","modified":1552118139294},{"_id":"themes/Material-T/layout/_partial/head.ejs","hash":"74d8032c46ba3a2c88a8a8c381627bdfd4ede586","modified":1552118139294},{"_id":"themes/Material-T/layout/_partial/nav.ejs","hash":"01670cf265507915926f3d6614966a6f9f493128","modified":1552118139294},{"_id":"themes/Material-T/layout/_partial/paginator.ejs","hash":"b07c3ca9d075ddcccf108ade75b788641a613a05","modified":1552118139294},{"_id":"themes/Material-T/layout/_partial/toc.ejs","hash":"cfc4bc1ca078cbf4e451d83f233c8fc14207603e","modified":1552118139295},{"_id":"themes/Material-T/source/css/post.styl","hash":"3c925d95aa47b97725b97a4ecfe7775f5bc8bbfe","modified":1552118139307},{"_id":"themes/Material-T/source/css/main.styl","hash":"eda4e6a8ee4b9eb655d0df76d7df3eeabc002be6","modified":1552118139307},{"_id":"themes/Material-T/source/css/Material_Icons.styl","hash":"c99a9e9a56460d9440a351ecb9a58ba49fa0e2d0","modified":1552118139304},{"_id":"themes/Material-T/source/js/main.js","hash":"76f5ecaa80f27c02b7173f689efca0086d65ae15","modified":1552118139322},{"_id":"themes/Material-T/source/img/avatar.jpg","hash":"add26ea8faa7edd6f498259099d757703128b915","modified":1552118139314},{"_id":"themes/Material-T/source/js/material-kit.min.js","hash":"e3e989763aca12e66add284cc85556806e1b37e1","modified":1552118139322},{"_id":"themes/Material-T/source/js/post.js","hash":"9fed1e24010efe9d5605c06329db2aef92e0237b","modified":1552118139324},{"_id":"themes/Material-T/source/img/about-banner.jpg","hash":"249a0be13d02009b725c875fc13a9a536ba58f18","modified":1552118139309},{"_id":"themes/Material-T/screenshot-index.png","hash":"dfdb72dc62977dc884792bb9abcb4481fb9405eb","modified":1552118139299},{"_id":"themes/Material-T/.git/objects/pack/pack-4376bc6e5d39e3bc8be391d03fd54bb65a65ff8f.idx","hash":"325ec9bf59932c2730080111a048814014a011ce","modified":1552118139258},{"_id":"themes/Material-T/.git/refs/heads/master","hash":"dbf9276a6b923ab405ce1093bdcb64c02b888a13","modified":1552118139278},{"_id":"themes/Material-T/layout/_partial/comments/disqus.ejs","hash":"ff6f5fff347e2239f48f872399e8ff2e44a06f5e","modified":1552118139293},{"_id":"themes/Material-T/layout/_partial/comments/valine.ejs","hash":"72d36d629df793dfa97d5ebd14f344908497c5cf","modified":1552118139293},{"_id":"themes/Material-T/layout/_partial/post_layout/2.ejs","hash":"fedb0a04d90f0fdc38e75ddb2933cd292097dd2c","modified":1552118139295},{"_id":"themes/Material-T/layout/_partial/post_layout/1.ejs","hash":"a1318abefc42d044a252d11e70ec808c6102ebcb","modified":1552118139295},{"_id":"themes/Material-T/source/css/Prettify/tomorrow-night-eighties.min.css","hash":"f654ece8ef13e740f844ce593912e040e3f21e5f","modified":1552118139304},{"_id":"themes/Material-T/source/css/Prettify/github.min.css","hash":"b156639209d7b9b27d3a8cd92bdd676ad358c628","modified":1552118139304},{"_id":"themes/Material-T/source/css/Prettify/tomorrow.min.css","hash":"1f61e1f9c60f8be82e3a8287a4f46d87b4551400","modified":1552118139305},{"_id":"themes/Material-T/source/css/Prettify/tomorrow-night.min.css","hash":"5bb9910676b08e6d2a6eac5ef07e08754de14a01","modified":1552118139305},{"_id":"themes/Material-T/source/img/archive-banner.jpg","hash":"4566d163680d977880144b74e82ad6db709cc648","modified":1552118139312},{"_id":"themes/Material-T/source/img/index-banner.jpg","hash":"995b88f8948bdafa0ccda87b22697c3d93a5434b","modified":1552118139316},{"_id":"themes/Material-T/source/js/core/popper.min.js","hash":"01bbb5c50ebe83e0b866a82a53514e5bc7939170","modified":1552118139321},{"_id":"themes/Material-T/source/js/plugins/prettify.js","hash":"38a0e547b123d32c9e61ae87b797b3b2f7929b7a","modified":1552118139323},{"_id":"themes/Material-T/source/js/core/bootstrap-material-design.min.js","hash":"739bd3fe963745c8ba7ec37e4f7aa0d1024afa93","modified":1552118139319},{"_id":"themes/Material-T/source/js/plugins/moment.min.js","hash":"430b6190b0a2c88bb7dd88a4302f02d03d266a94","modified":1552118139323},{"_id":"themes/Material-T/.git/logs/refs/heads/master","hash":"9ecfaf3208bfde7506fb8354dc214da6da682311","modified":1552118139281},{"_id":"themes/Material-T/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1552118139276},{"_id":"themes/Material-T/source/js/core/jquery.min.js","hash":"ddb65f1fb486e0142e2ad61d11621e93bd34e4c9","modified":1552118139321},{"_id":"themes/Material-T/source/img/post-banner.jpg","hash":"0f01b36d3a318716cc84be201aaddf6b11df8e80","modified":1552118139318},{"_id":"themes/Material-T/.git/logs/refs/remotes/origin/HEAD","hash":"9ecfaf3208bfde7506fb8354dc214da6da682311","modified":1552118139276},{"_id":"themes/Material-T/source/css/Material-Kit.styl","hash":"5f8cec711f770c818b04778f26667373ca9f95d3","modified":1552118139303},{"_id":"themes/Material-T/.git/objects/pack/pack-4376bc6e5d39e3bc8be391d03fd54bb65a65ff8f.pack","hash":"f8b86d2f15b82555dcb303c1ffbb6514ece7490c","modified":1552118139257},{"_id":"public/about/index.html","hash":"588c7d414689a39d5125db026e788bfe92c7cc34","modified":1552121099159},{"_id":"public/2019/03/09/hello-world/index.html","hash":"3e0e35e77cf7114c0cd5cb62df354c9a8885df2c","modified":1552121099159},{"_id":"public/index.html","hash":"541ee8ae6268bfd20d20208f61cc65839f2b3958","modified":1563385068694},{"_id":"public/archives/index.html","hash":"49aad4db7d797a79c740964c971d9af656196ce6","modified":1563385068686},{"_id":"public/archives/2019/index.html","hash":"49aad4db7d797a79c740964c971d9af656196ce6","modified":1563385068686},{"_id":"public/archives/2019/03/index.html","hash":"830431fe5348f446ac71cf9d9553b68760985ab9","modified":1563385068694},{"_id":"public/favicon.png","hash":"7e79eceaaab4def3d4b905d1c69dc04d52f18f06","modified":1552121099167},{"_id":"public/apple-touch-icon.png","hash":"7e79eceaaab4def3d4b905d1c69dc04d52f18f06","modified":1552121099168},{"_id":"public/img/avatar.jpg","hash":"add26ea8faa7edd6f498259099d757703128b915","modified":1552121099168},{"_id":"public/img/about-banner.jpg","hash":"249a0be13d02009b725c875fc13a9a536ba58f18","modified":1552121101376},{"_id":"public/css/post.css","hash":"72046eae29c1c1721e2094c99a070ef5f76f4b99","modified":1552121101430},{"_id":"public/js/main.js","hash":"76f5ecaa80f27c02b7173f689efca0086d65ae15","modified":1552121101430},{"_id":"public/js/material-kit.min.js","hash":"e3e989763aca12e66add284cc85556806e1b37e1","modified":1552121101431},{"_id":"public/js/post.js","hash":"9fed1e24010efe9d5605c06329db2aef92e0237b","modified":1552121101431},{"_id":"public/css/Prettify/tomorrow-night-eighties.min.css","hash":"f654ece8ef13e740f844ce593912e040e3f21e5f","modified":1552121101431},{"_id":"public/css/Prettify/github.min.css","hash":"b156639209d7b9b27d3a8cd92bdd676ad358c628","modified":1552121101431},{"_id":"public/css/Prettify/tomorrow.min.css","hash":"1f61e1f9c60f8be82e3a8287a4f46d87b4551400","modified":1552121101431},{"_id":"public/css/Prettify/tomorrow-night.min.css","hash":"5bb9910676b08e6d2a6eac5ef07e08754de14a01","modified":1552121101431},{"_id":"public/css/main.css","hash":"c20adcf8251b6f76c26b995c85762faccc6ae265","modified":1552121101431},{"_id":"public/img/archive-banner.jpg","hash":"4566d163680d977880144b74e82ad6db709cc648","modified":1552121101431},{"_id":"public/css/Material_Icons.css","hash":"c57bb265c3faa3405847bde4fa238ffb0d5e38e4","modified":1552121101434},{"_id":"public/js/plugins/prettify.js","hash":"38a0e547b123d32c9e61ae87b797b3b2f7929b7a","modified":1552121101434},{"_id":"public/img/index-banner.jpg","hash":"995b88f8948bdafa0ccda87b22697c3d93a5434b","modified":1552121101437},{"_id":"public/img/post-banner.jpg","hash":"0f01b36d3a318716cc84be201aaddf6b11df8e80","modified":1552121101439},{"_id":"public/js/core/popper.min.js","hash":"01bbb5c50ebe83e0b866a82a53514e5bc7939170","modified":1552121101442},{"_id":"public/js/plugins/moment.min.js","hash":"430b6190b0a2c88bb7dd88a4302f02d03d266a94","modified":1552121101451},{"_id":"public/js/core/bootstrap-material-design.min.js","hash":"739bd3fe963745c8ba7ec37e4f7aa0d1024afa93","modified":1552121101452},{"_id":"public/js/core/jquery.min.js","hash":"ddb65f1fb486e0142e2ad61d11621e93bd34e4c9","modified":1552121101459},{"_id":"public/css/Material-Kit.css","hash":"c7e17eb219effc4f87645c6600038ca21e87a1b7","modified":1552121101799},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1561474865325},{"_id":"source/_posts/20180718.md","hash":"c6b07be939fd10e9d851ab9a6384ebedf6c3a391","modified":1561475122351},{"_id":"public/2019/06/25/20180718/index.html","hash":"17cd0bbe94154ae19441de78fdc59d3eb6d84a0c","modified":1561475129197},{"_id":"public/archives/2019/06/index.html","hash":"e03a2a82266c45374b5c32c137ea8c099cfb5882","modified":1563385068694},{"_id":"source/_posts/20180719.md","hash":"f100dc8e625c3b44970693d07e9dda5bc9defc0c","modified":1563385088636},{"_id":"public/2019/07/18/20180719/index.html","hash":"d1d1ec11175a5c1237220ae49db9a127388472c1","modified":1563385101469},{"_id":"public/archives/2019/07/index.html","hash":"3e166e69dc61b1df810f0eaea4e7fa098b038e4a","modified":1563385068695}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2019-03-09T08:10:51.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-03-09 16:10:51\ntype: \"about\"\n---\n","updated":"2019-03-09T08:11:15.496Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjt17qtqz0000sh09h60sh3c9","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello Hexo","_content":"\n自建站博客实例\n\n文章内容会同步更新我的 GitHub [blog](https://github.com/EmiyaGm/blog) 项目里的 issues 内容\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello Hexo\n---\n\n自建站博客实例\n\n文章内容会同步更新我的 GitHub [blog](https://github.com/EmiyaGm/blog) 项目里的 issues 内容\n","slug":"hello-world","published":1,"date":"2019-03-09T07:31:28.691Z","updated":"2019-03-09T07:42:19.597Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt17qtr00001sh096eug18xy","content":"<p>自建站博客实例</p>\n<p>文章内容会同步更新我的 GitHub <a href=\"https://github.com/EmiyaGm/blog\" target=\"_blank\" rel=\"noopener\">blog</a> 项目里的 issues 内容</p>\n","site":{"data":{}},"excerpt":"","more":"<p>自建站博客实例</p>\n<p>文章内容会同步更新我的 GitHub <a href=\"https://github.com/EmiyaGm/blog\" target=\"_blank\" rel=\"noopener\">blog</a> 项目里的 issues 内容</p>\n"},{"title":"关于react中更新state来渲染局部页面的加深理解","_content":"\n最近换了新的工作，也开始学习新的前端框架react，由于之前我一直都是使用原生JavaScript和jQuery的结合，对于dom操作这一块，十分随意。大家都知道，jQuery提供了很方便的方法来获取dom节点并进行操作，例如，对于一个img点击更换图片地址的功能，我们在jQuery中会这么写：\n\n```javascript\n<img src=\"1.png\" id=\"Img\"/>\n<script>\n    $('#Img').click(function(e){\n        if($(e).src === '1.png'){\n            $(e).attr('src','2.png');\n        }else{\n            $(e).attr('src','1.png');\n        }\n    });\n</script>\n```\n\n但是在react中，我们都知道，React 的核心思想是组件化的思想，应用由组件搭建而成，而组件中最重要的概念是State（状态），State是一个组件的UI数据模型，是组件渲染时的数据依据。\n这就告诉我们，组件发生的任何页面展现上的变化，都是由于state的更改所导致的，不管你是自身的state，还是从父元素的state里传过来当做自己的props，只要该state发生变化，必然会导致组件的重新渲染。\n由于刚接触加上长期使用jQuery操作dom的原因，我一开始写了一段很蠢得代码\n\n```javascript\nimport Selected from '../../assets/selected.png';\nimport Select from '../../assets/select.png';\n<img\n    alt=\"\"\n    src={selectOrNot ? Selected : Select}\n    style={{ marginTop: '-2px', marginRight: '10px' }}\n    onClick={this.mouseClick.bind(this)}\n    id=\"currentWtImg\"\n/>\nmouseClick(e) {\n    if (e.target.src === Select) {\n      if (e.target.id === 'currentWtImg') {\n        this.props.changeCurrentHideTrading();\n      } else {\n        this.props.changeHistoryHideTrading();\n      }\n      e.target.src = Selected;\n    } else {\n      if (e.target.id === 'currentWtImg') {\n        this.props.changeCurrentHideTrading();\n      } else {\n        this.props.changeHistoryHideTrading();\n      }\n      e.target.src = Select;\n    }\n  }\n```\n\n这段代码的思想就是，通过点击事件判断点击的时候该img元素的src地址是没选中的图片还是被选中的图片，如果是没选中的图片，那就把他的图片的地址换成被选中的图片，反之亦然。\n这是一个很纯粹的jQuery的思维，但是放在react中，这是不行的。\n我们在这个react代码里面，定义了一个selectOrNot，继承自父元素的state，用来做为该img的props，img的图片地址是通过该props的值判断加载对应的地址的，并且提供了changeCurrentHideTrading()用来更改该state，那么其实我们只需要调用该更改方法，img在页面上就会立刻重新渲染，再通过selectOrNot的值，来判断这次加载使用哪个图片地址，review后的代码如下：\n\n```javascript\nmouseClick(e) {\n    if (e.target.id === 'currentWtImg') {\n      this.props.changeCurrentHideTrading();\n    } else {\n      this.props.changeHistoryHideTrading();\n    }\n  }\n```\n\n写于 2018-07-18","source":"_posts/20180718.md","raw":"---\ntitle: 关于react中更新state来渲染局部页面的加深理解\n---\n\n最近换了新的工作，也开始学习新的前端框架react，由于之前我一直都是使用原生JavaScript和jQuery的结合，对于dom操作这一块，十分随意。大家都知道，jQuery提供了很方便的方法来获取dom节点并进行操作，例如，对于一个img点击更换图片地址的功能，我们在jQuery中会这么写：\n\n```javascript\n<img src=\"1.png\" id=\"Img\"/>\n<script>\n    $('#Img').click(function(e){\n        if($(e).src === '1.png'){\n            $(e).attr('src','2.png');\n        }else{\n            $(e).attr('src','1.png');\n        }\n    });\n</script>\n```\n\n但是在react中，我们都知道，React 的核心思想是组件化的思想，应用由组件搭建而成，而组件中最重要的概念是State（状态），State是一个组件的UI数据模型，是组件渲染时的数据依据。\n这就告诉我们，组件发生的任何页面展现上的变化，都是由于state的更改所导致的，不管你是自身的state，还是从父元素的state里传过来当做自己的props，只要该state发生变化，必然会导致组件的重新渲染。\n由于刚接触加上长期使用jQuery操作dom的原因，我一开始写了一段很蠢得代码\n\n```javascript\nimport Selected from '../../assets/selected.png';\nimport Select from '../../assets/select.png';\n<img\n    alt=\"\"\n    src={selectOrNot ? Selected : Select}\n    style={{ marginTop: '-2px', marginRight: '10px' }}\n    onClick={this.mouseClick.bind(this)}\n    id=\"currentWtImg\"\n/>\nmouseClick(e) {\n    if (e.target.src === Select) {\n      if (e.target.id === 'currentWtImg') {\n        this.props.changeCurrentHideTrading();\n      } else {\n        this.props.changeHistoryHideTrading();\n      }\n      e.target.src = Selected;\n    } else {\n      if (e.target.id === 'currentWtImg') {\n        this.props.changeCurrentHideTrading();\n      } else {\n        this.props.changeHistoryHideTrading();\n      }\n      e.target.src = Select;\n    }\n  }\n```\n\n这段代码的思想就是，通过点击事件判断点击的时候该img元素的src地址是没选中的图片还是被选中的图片，如果是没选中的图片，那就把他的图片的地址换成被选中的图片，反之亦然。\n这是一个很纯粹的jQuery的思维，但是放在react中，这是不行的。\n我们在这个react代码里面，定义了一个selectOrNot，继承自父元素的state，用来做为该img的props，img的图片地址是通过该props的值判断加载对应的地址的，并且提供了changeCurrentHideTrading()用来更改该state，那么其实我们只需要调用该更改方法，img在页面上就会立刻重新渲染，再通过selectOrNot的值，来判断这次加载使用哪个图片地址，review后的代码如下：\n\n```javascript\nmouseClick(e) {\n    if (e.target.id === 'currentWtImg') {\n      this.props.changeCurrentHideTrading();\n    } else {\n      this.props.changeHistoryHideTrading();\n    }\n  }\n```\n\n写于 2018-07-18","slug":"20180718","published":1,"date":"2019-06-25T14:59:44.849Z","updated":"2019-06-25T15:05:22.351Z","_id":"cjxbxywq40000yx094aca2rg4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近换了新的工作，也开始学习新的前端框架react，由于之前我一直都是使用原生JavaScript和jQuery的结合，对于dom操作这一块，十分随意。大家都知道，jQuery提供了很方便的方法来获取dom节点并进行操作，例如，对于一个img点击更换图片地址的功能，我们在jQuery中会这么写：</p>\n<pre><code class=\"javascript\">&lt;img src=&quot;1.png&quot; id=&quot;Img&quot;/&gt;\n&lt;script&gt;\n    $(&#39;#Img&#39;).click(function(e){\n        if($(e).src === &#39;1.png&#39;){\n            $(e).attr(&#39;src&#39;,&#39;2.png&#39;);\n        }else{\n            $(e).attr(&#39;src&#39;,&#39;1.png&#39;);\n        }\n    });\n&lt;/script&gt;\n</code></pre>\n<p>但是在react中，我们都知道，React 的核心思想是组件化的思想，应用由组件搭建而成，而组件中最重要的概念是State（状态），State是一个组件的UI数据模型，是组件渲染时的数据依据。<br>这就告诉我们，组件发生的任何页面展现上的变化，都是由于state的更改所导致的，不管你是自身的state，还是从父元素的state里传过来当做自己的props，只要该state发生变化，必然会导致组件的重新渲染。<br>由于刚接触加上长期使用jQuery操作dom的原因，我一开始写了一段很蠢得代码</p>\n<pre><code class=\"javascript\">import Selected from &#39;../../assets/selected.png&#39;;\nimport Select from &#39;../../assets/select.png&#39;;\n&lt;img\n    alt=&quot;&quot;\n    src={selectOrNot ? Selected : Select}\n    style={{ marginTop: '-2px', marginRight: '10px' }}\n    onClick={this.mouseClick.bind(this)}\n    id=&quot;currentWtImg&quot;\n/&gt;\nmouseClick(e) {\n    if (e.target.src === Select) {\n      if (e.target.id === &#39;currentWtImg&#39;) {\n        this.props.changeCurrentHideTrading();\n      } else {\n        this.props.changeHistoryHideTrading();\n      }\n      e.target.src = Selected;\n    } else {\n      if (e.target.id === &#39;currentWtImg&#39;) {\n        this.props.changeCurrentHideTrading();\n      } else {\n        this.props.changeHistoryHideTrading();\n      }\n      e.target.src = Select;\n    }\n  }\n</code></pre>\n<p>这段代码的思想就是，通过点击事件判断点击的时候该img元素的src地址是没选中的图片还是被选中的图片，如果是没选中的图片，那就把他的图片的地址换成被选中的图片，反之亦然。<br>这是一个很纯粹的jQuery的思维，但是放在react中，这是不行的。<br>我们在这个react代码里面，定义了一个selectOrNot，继承自父元素的state，用来做为该img的props，img的图片地址是通过该props的值判断加载对应的地址的，并且提供了changeCurrentHideTrading()用来更改该state，那么其实我们只需要调用该更改方法，img在页面上就会立刻重新渲染，再通过selectOrNot的值，来判断这次加载使用哪个图片地址，review后的代码如下：</p>\n<pre><code class=\"javascript\">mouseClick(e) {\n    if (e.target.id === &#39;currentWtImg&#39;) {\n      this.props.changeCurrentHideTrading();\n    } else {\n      this.props.changeHistoryHideTrading();\n    }\n  }\n</code></pre>\n<p>写于 2018-07-18</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近换了新的工作，也开始学习新的前端框架react，由于之前我一直都是使用原生JavaScript和jQuery的结合，对于dom操作这一块，十分随意。大家都知道，jQuery提供了很方便的方法来获取dom节点并进行操作，例如，对于一个img点击更换图片地址的功能，我们在jQuery中会这么写：</p>\n<pre><code class=\"javascript\">&lt;img src=&quot;1.png&quot; id=&quot;Img&quot;/&gt;\n&lt;script&gt;\n    $(&#39;#Img&#39;).click(function(e){\n        if($(e).src === &#39;1.png&#39;){\n            $(e).attr(&#39;src&#39;,&#39;2.png&#39;);\n        }else{\n            $(e).attr(&#39;src&#39;,&#39;1.png&#39;);\n        }\n    });\n&lt;/script&gt;\n</code></pre>\n<p>但是在react中，我们都知道，React 的核心思想是组件化的思想，应用由组件搭建而成，而组件中最重要的概念是State（状态），State是一个组件的UI数据模型，是组件渲染时的数据依据。<br>这就告诉我们，组件发生的任何页面展现上的变化，都是由于state的更改所导致的，不管你是自身的state，还是从父元素的state里传过来当做自己的props，只要该state发生变化，必然会导致组件的重新渲染。<br>由于刚接触加上长期使用jQuery操作dom的原因，我一开始写了一段很蠢得代码</p>\n<pre><code class=\"javascript\">import Selected from &#39;../../assets/selected.png&#39;;\nimport Select from &#39;../../assets/select.png&#39;;\n&lt;img\n    alt=&quot;&quot;\n    src={selectOrNot ? Selected : Select}\n    style={{ marginTop: '-2px', marginRight: '10px' }}\n    onClick={this.mouseClick.bind(this)}\n    id=&quot;currentWtImg&quot;\n/&gt;\nmouseClick(e) {\n    if (e.target.src === Select) {\n      if (e.target.id === &#39;currentWtImg&#39;) {\n        this.props.changeCurrentHideTrading();\n      } else {\n        this.props.changeHistoryHideTrading();\n      }\n      e.target.src = Selected;\n    } else {\n      if (e.target.id === &#39;currentWtImg&#39;) {\n        this.props.changeCurrentHideTrading();\n      } else {\n        this.props.changeHistoryHideTrading();\n      }\n      e.target.src = Select;\n    }\n  }\n</code></pre>\n<p>这段代码的思想就是，通过点击事件判断点击的时候该img元素的src地址是没选中的图片还是被选中的图片，如果是没选中的图片，那就把他的图片的地址换成被选中的图片，反之亦然。<br>这是一个很纯粹的jQuery的思维，但是放在react中，这是不行的。<br>我们在这个react代码里面，定义了一个selectOrNot，继承自父元素的state，用来做为该img的props，img的图片地址是通过该props的值判断加载对应的地址的，并且提供了changeCurrentHideTrading()用来更改该state，那么其实我们只需要调用该更改方法，img在页面上就会立刻重新渲染，再通过selectOrNot的值，来判断这次加载使用哪个图片地址，review后的代码如下：</p>\n<pre><code class=\"javascript\">mouseClick(e) {\n    if (e.target.id === &#39;currentWtImg&#39;) {\n      this.props.changeCurrentHideTrading();\n    } else {\n      this.props.changeHistoryHideTrading();\n    }\n  }\n</code></pre>\n<p>写于 2018-07-18</p>\n"},{"title":"关于react组件生命周期的妙用","_content":"\n今天早上处理了一个bug，主要情况是这样的：\n我们通过markettable这个组件的一个state叫做activekey来控制该组件内的tab的选中项，tab的内容是数据展示的表格，并且每一条数据都可以收藏和取消收藏，最后有一个收藏的tab项来查看收藏的数据。\n需求是，当该用户的收藏中有数据，那么在进入该页面的时候，tab默认切换到收藏项上，如果收藏没有数据，那么默认切换到第一个tab项。\n一开始我们的逻辑是这样的：\n给这个组件设置一个state叫做activekey，初始值是一个空字符串，用来作为tab组件的activekey属性的取值，控制tab的当前选择项，每一次change都会触发tab的onchange监听，然后会给这个activekey赋当前选中的tab项的名称这个值，初始加载的时候，该tab的activekey属性取值会先进行判断state activekey有没有值，有的话就用state activekey作为tab的activekey属性的值，如果没有，就会去判断收藏栏目里面有没有值，有值就会让tab切换到收藏栏，没有就会让tab切换到第一栏。\n\n```javascript\nexport default class MarketTable extends Component {\n  constructor() {\n    super();\n    this.state = {\n      activeKey: ''\n    };\n  }\n\n  .....\n\n  <Tabs\n       activeKey={this.state.activeKey || \n                           (Object,keys(favoriteLists).length > 0 ? '收藏' : markerTabList[0].name)}\n       type=\"card\"\n       onChange={activeKey => {\n           this.setState({\n               activeKey\n           });\n      }}\n   >\n```\n\n然后测试报了一个十分奇妙的bug，就是当我们第一次进入这个页面且该账号收藏中没有数据，那么该tab会默认切换到第一栏，这个没有问题。但是当我们在首次进入没有收藏数据的页面中后，点击一条数据的收藏，那么就会立刻将tab切换到收藏栏。\n经过分析发现，是因为初始化渲染结束之后，用来控制activekey的state activekey为空值，但是tab却已经切换到第一项，当我们点击收藏之后，由于state activekey为空，所以我们会进行如下判断\n\n```javascript\nObject,keys(favoriteLists).length > 0 ? '收藏' : markerTabList[0].name)\n```\n\n得到的结果是收藏，所以tab就会切换到收藏栏目。\n这个问题本质上是因为state activekey和tab的activekey属性在第一次加载完成之后没有保持一致。\n经过思考分析，解决方案如下：\n采用react组件的生命周期函数componentWillReceiveProps\n我们知道componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。\n解决的思路是这样的，因为初始化的时候，由于要请求接口更新收藏的数据，所以我们会改变一次props然后触发componentWillReceiveProps这个方法，并且会改变favoriteList这个props，那么在这个时候我们只要去改变一次state activekey的值，做到与当前tab上的activekey的属性对应一致即可。\n并且由于每一次的收藏操作都会触发componentWillReceiveProps该方法，所有我们需要进行一些判断加以限制，并且把原先写在tab上的判断挪入当中，统一管理。\n\n```javascript\ncomponentWillReceiveProps(nextProps) {\n    if (nextProps.favoriteList !== this.props.favoriteList) {\n      this.setState({\n        activeKey:\n          this.state.activeKey ||\n          (Object.keys(nextProps.favoriteList).length > 0 ? '自选' : 'CNYT')\n      });\n    }\n  }\n\n.....\n\n<Tabs\n    activeKey={this.state.activeKey}\n    type=\"card\"\n    onChange={activeKey => {\n         this.setState({\n             activeKey\n          });\n    }}\n>\n```\n\n![avatar](https://images2015.cnblogs.com/blog/588767/201612/588767-20161205190022429-1074951616.jpg)\n\n写于 2018-07-19","source":"_posts/20180719.md","raw":"---\ntitle: 关于react组件生命周期的妙用\n---\n\n今天早上处理了一个bug，主要情况是这样的：\n我们通过markettable这个组件的一个state叫做activekey来控制该组件内的tab的选中项，tab的内容是数据展示的表格，并且每一条数据都可以收藏和取消收藏，最后有一个收藏的tab项来查看收藏的数据。\n需求是，当该用户的收藏中有数据，那么在进入该页面的时候，tab默认切换到收藏项上，如果收藏没有数据，那么默认切换到第一个tab项。\n一开始我们的逻辑是这样的：\n给这个组件设置一个state叫做activekey，初始值是一个空字符串，用来作为tab组件的activekey属性的取值，控制tab的当前选择项，每一次change都会触发tab的onchange监听，然后会给这个activekey赋当前选中的tab项的名称这个值，初始加载的时候，该tab的activekey属性取值会先进行判断state activekey有没有值，有的话就用state activekey作为tab的activekey属性的值，如果没有，就会去判断收藏栏目里面有没有值，有值就会让tab切换到收藏栏，没有就会让tab切换到第一栏。\n\n```javascript\nexport default class MarketTable extends Component {\n  constructor() {\n    super();\n    this.state = {\n      activeKey: ''\n    };\n  }\n\n  .....\n\n  <Tabs\n       activeKey={this.state.activeKey || \n                           (Object,keys(favoriteLists).length > 0 ? '收藏' : markerTabList[0].name)}\n       type=\"card\"\n       onChange={activeKey => {\n           this.setState({\n               activeKey\n           });\n      }}\n   >\n```\n\n然后测试报了一个十分奇妙的bug，就是当我们第一次进入这个页面且该账号收藏中没有数据，那么该tab会默认切换到第一栏，这个没有问题。但是当我们在首次进入没有收藏数据的页面中后，点击一条数据的收藏，那么就会立刻将tab切换到收藏栏。\n经过分析发现，是因为初始化渲染结束之后，用来控制activekey的state activekey为空值，但是tab却已经切换到第一项，当我们点击收藏之后，由于state activekey为空，所以我们会进行如下判断\n\n```javascript\nObject,keys(favoriteLists).length > 0 ? '收藏' : markerTabList[0].name)\n```\n\n得到的结果是收藏，所以tab就会切换到收藏栏目。\n这个问题本质上是因为state activekey和tab的activekey属性在第一次加载完成之后没有保持一致。\n经过思考分析，解决方案如下：\n采用react组件的生命周期函数componentWillReceiveProps\n我们知道componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。\n解决的思路是这样的，因为初始化的时候，由于要请求接口更新收藏的数据，所以我们会改变一次props然后触发componentWillReceiveProps这个方法，并且会改变favoriteList这个props，那么在这个时候我们只要去改变一次state activekey的值，做到与当前tab上的activekey的属性对应一致即可。\n并且由于每一次的收藏操作都会触发componentWillReceiveProps该方法，所有我们需要进行一些判断加以限制，并且把原先写在tab上的判断挪入当中，统一管理。\n\n```javascript\ncomponentWillReceiveProps(nextProps) {\n    if (nextProps.favoriteList !== this.props.favoriteList) {\n      this.setState({\n        activeKey:\n          this.state.activeKey ||\n          (Object.keys(nextProps.favoriteList).length > 0 ? '自选' : 'CNYT')\n      });\n    }\n  }\n\n.....\n\n<Tabs\n    activeKey={this.state.activeKey}\n    type=\"card\"\n    onChange={activeKey => {\n         this.setState({\n             activeKey\n          });\n    }}\n>\n```\n\n![avatar](https://images2015.cnblogs.com/blog/588767/201612/588767-20161205190022429-1074951616.jpg)\n\n写于 2018-07-19","slug":"20180719","published":1,"date":"2019-07-17T17:35:22.198Z","updated":"2019-07-17T17:38:08.636Z","_id":"cjy7j3r9r00009h2ykk4n37e9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今天早上处理了一个bug，主要情况是这样的：<br>我们通过markettable这个组件的一个state叫做activekey来控制该组件内的tab的选中项，tab的内容是数据展示的表格，并且每一条数据都可以收藏和取消收藏，最后有一个收藏的tab项来查看收藏的数据。<br>需求是，当该用户的收藏中有数据，那么在进入该页面的时候，tab默认切换到收藏项上，如果收藏没有数据，那么默认切换到第一个tab项。<br>一开始我们的逻辑是这样的：<br>给这个组件设置一个state叫做activekey，初始值是一个空字符串，用来作为tab组件的activekey属性的取值，控制tab的当前选择项，每一次change都会触发tab的onchange监听，然后会给这个activekey赋当前选中的tab项的名称这个值，初始加载的时候，该tab的activekey属性取值会先进行判断state activekey有没有值，有的话就用state activekey作为tab的activekey属性的值，如果没有，就会去判断收藏栏目里面有没有值，有值就会让tab切换到收藏栏，没有就会让tab切换到第一栏。</p>\n<pre><code class=\"javascript\">export default class MarketTable extends Component {\n  constructor() {\n    super();\n    this.state = {\n      activeKey: &#39;&#39;\n    };\n  }\n\n  .....\n\n  &lt;Tabs\n       activeKey={this.state.activeKey || \n                           (Object,keys(favoriteLists).length &gt; 0 ? &#39;收藏&#39; : markerTabList[0].name)}\n       type=&quot;card&quot;\n       onChange={activeKey =&gt; {\n           this.setState({\n               activeKey\n           });\n      }}\n   &gt;\n</code></pre>\n<p>然后测试报了一个十分奇妙的bug，就是当我们第一次进入这个页面且该账号收藏中没有数据，那么该tab会默认切换到第一栏，这个没有问题。但是当我们在首次进入没有收藏数据的页面中后，点击一条数据的收藏，那么就会立刻将tab切换到收藏栏。<br>经过分析发现，是因为初始化渲染结束之后，用来控制activekey的state activekey为空值，但是tab却已经切换到第一项，当我们点击收藏之后，由于state activekey为空，所以我们会进行如下判断</p>\n<pre><code class=\"javascript\">Object,keys(favoriteLists).length &gt; 0 ? &#39;收藏&#39; : markerTabList[0].name)\n</code></pre>\n<p>得到的结果是收藏，所以tab就会切换到收藏栏目。<br>这个问题本质上是因为state activekey和tab的activekey属性在第一次加载完成之后没有保持一致。<br>经过思考分析，解决方案如下：<br>采用react组件的生命周期函数componentWillReceiveProps<br>我们知道componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。<br>解决的思路是这样的，因为初始化的时候，由于要请求接口更新收藏的数据，所以我们会改变一次props然后触发componentWillReceiveProps这个方法，并且会改变favoriteList这个props，那么在这个时候我们只要去改变一次state activekey的值，做到与当前tab上的activekey的属性对应一致即可。<br>并且由于每一次的收藏操作都会触发componentWillReceiveProps该方法，所有我们需要进行一些判断加以限制，并且把原先写在tab上的判断挪入当中，统一管理。</p>\n<pre><code class=\"javascript\">componentWillReceiveProps(nextProps) {\n    if (nextProps.favoriteList !== this.props.favoriteList) {\n      this.setState({\n        activeKey:\n          this.state.activeKey ||\n          (Object.keys(nextProps.favoriteList).length &gt; 0 ? &#39;自选&#39; : &#39;CNYT&#39;)\n      });\n    }\n  }\n\n.....\n\n&lt;Tabs\n    activeKey={this.state.activeKey}\n    type=&quot;card&quot;\n    onChange={activeKey =&gt; {\n         this.setState({\n             activeKey\n          });\n    }}\n&gt;\n</code></pre>\n<p><img src=\"https://images2015.cnblogs.com/blog/588767/201612/588767-20161205190022429-1074951616.jpg\" alt=\"avatar\"></p>\n<p>写于 2018-07-19</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天早上处理了一个bug，主要情况是这样的：<br>我们通过markettable这个组件的一个state叫做activekey来控制该组件内的tab的选中项，tab的内容是数据展示的表格，并且每一条数据都可以收藏和取消收藏，最后有一个收藏的tab项来查看收藏的数据。<br>需求是，当该用户的收藏中有数据，那么在进入该页面的时候，tab默认切换到收藏项上，如果收藏没有数据，那么默认切换到第一个tab项。<br>一开始我们的逻辑是这样的：<br>给这个组件设置一个state叫做activekey，初始值是一个空字符串，用来作为tab组件的activekey属性的取值，控制tab的当前选择项，每一次change都会触发tab的onchange监听，然后会给这个activekey赋当前选中的tab项的名称这个值，初始加载的时候，该tab的activekey属性取值会先进行判断state activekey有没有值，有的话就用state activekey作为tab的activekey属性的值，如果没有，就会去判断收藏栏目里面有没有值，有值就会让tab切换到收藏栏，没有就会让tab切换到第一栏。</p>\n<pre><code class=\"javascript\">export default class MarketTable extends Component {\n  constructor() {\n    super();\n    this.state = {\n      activeKey: &#39;&#39;\n    };\n  }\n\n  .....\n\n  &lt;Tabs\n       activeKey={this.state.activeKey || \n                           (Object,keys(favoriteLists).length &gt; 0 ? &#39;收藏&#39; : markerTabList[0].name)}\n       type=&quot;card&quot;\n       onChange={activeKey =&gt; {\n           this.setState({\n               activeKey\n           });\n      }}\n   &gt;\n</code></pre>\n<p>然后测试报了一个十分奇妙的bug，就是当我们第一次进入这个页面且该账号收藏中没有数据，那么该tab会默认切换到第一栏，这个没有问题。但是当我们在首次进入没有收藏数据的页面中后，点击一条数据的收藏，那么就会立刻将tab切换到收藏栏。<br>经过分析发现，是因为初始化渲染结束之后，用来控制activekey的state activekey为空值，但是tab却已经切换到第一项，当我们点击收藏之后，由于state activekey为空，所以我们会进行如下判断</p>\n<pre><code class=\"javascript\">Object,keys(favoriteLists).length &gt; 0 ? &#39;收藏&#39; : markerTabList[0].name)\n</code></pre>\n<p>得到的结果是收藏，所以tab就会切换到收藏栏目。<br>这个问题本质上是因为state activekey和tab的activekey属性在第一次加载完成之后没有保持一致。<br>经过思考分析，解决方案如下：<br>采用react组件的生命周期函数componentWillReceiveProps<br>我们知道componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。<br>解决的思路是这样的，因为初始化的时候，由于要请求接口更新收藏的数据，所以我们会改变一次props然后触发componentWillReceiveProps这个方法，并且会改变favoriteList这个props，那么在这个时候我们只要去改变一次state activekey的值，做到与当前tab上的activekey的属性对应一致即可。<br>并且由于每一次的收藏操作都会触发componentWillReceiveProps该方法，所有我们需要进行一些判断加以限制，并且把原先写在tab上的判断挪入当中，统一管理。</p>\n<pre><code class=\"javascript\">componentWillReceiveProps(nextProps) {\n    if (nextProps.favoriteList !== this.props.favoriteList) {\n      this.setState({\n        activeKey:\n          this.state.activeKey ||\n          (Object.keys(nextProps.favoriteList).length &gt; 0 ? &#39;自选&#39; : &#39;CNYT&#39;)\n      });\n    }\n  }\n\n.....\n\n&lt;Tabs\n    activeKey={this.state.activeKey}\n    type=&quot;card&quot;\n    onChange={activeKey =&gt; {\n         this.setState({\n             activeKey\n          });\n    }}\n&gt;\n</code></pre>\n<p><img src=\"https://images2015.cnblogs.com/blog/588767/201612/588767-20161205190022429-1074951616.jpg\" alt=\"avatar\"></p>\n<p>写于 2018-07-19</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}